## this, call, apply, bind.
`this`
---

Указатель на объект. В JS происходит позднее связывание и this определяется при вызове функции.
В пределах функции значение this зависит от того, каким образом вызвана функция.

В большинстве случаев значение `this` определяется тем, каким образом вызвана функция. Значение this не может быть установлено путем присваивания во время исполнения кода и может иметь разное значение при каждом вызове функции. В ES5 представлен метод `bind` , чтобы определить значение ключевого слова this независимо от того, как вызвана функция. Также в ECMAScript 2015 представлены стрелочные функции, `this` которых привязан к окружению, в котором была создана стрелочная функция.

```javascript
function foo() {
    console.log( this.bar );
}

var bar = "global";

var obj1 = {
    bar: "obj1",
    foo: foo
};

var obj2 = {
    bar: "obj2"
};

// --------

foo();              // "global"
obj1.foo();         // "obj1"
foo.call( obj2 );   // "obj2"
new foo();          // undefined
```

В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект.
```javascript
var globalObject = this;
var foo = (() => this);
console.log(foo() === globalObject); // true
```

Не важно, как функция foo() будет вызвана, ее this будет указывать на глобальный объект. this будет сохранять свое значение, даже если функция foo() будет вызвана как метод обьекта (что в обычных функциях связывает this с объектом вызова) или с использованием методов call, apply или bind:
```javascript
// Вызов функции как метода объекта
var obj = {foo: foo};
console.log(obj.foo() === globalObject); // true

// Попытка установить this с помощью call
console.log(foo.call(obj) === globalObject); // true

// Попытка установить this с помощью bind
foo = foo.bind(obj);
console.log(foo() === globalObject); // true
```


`call`
---

Метод `call()` вызывает функцию с указанным значением `this` и индивидуально предоставленными аргументами.

 **Синтаксис**

`fun.call(thisArg[, arg1[, arg2[, ...]]])`

Параметры

`thisArg`
    Значение this, предоставляемое для вызова функции fun. Обратите внимание, что this может не быть реальным значением, видимым этим методом: если метод является функцией в нестрогом режиме, значения null и undefined будут заменены глобальным объектом, а примитивные значения будут упакованы в объекты.

`arg1, arg2, ...`
    Аргументы для объекта.

Вы можете присваивать различные объекты `this` при вызове существующей функции. `this` ссылается на текущий объект, вызвавший объект. С помощью `call` вы можете написать метод один раз, а затем наследовать его в других объектах, без необходимости переписывать метод для каждого нового объекта.

Пример
```javascript
var user = {
  firstName: "Василий",
  surname: "Петров",
  patronym: "Иванович"
};

function showFullName(firstPart, lastPart) {
  alert( this[firstPart] + " " + this[lastPart] );
}

// f.call(контекст, аргумент1, аргумент2, ...)
showFullName.call(user, 'firstName', 'surname') // "Василий Петров"
showFullName.call(user, 'firstName', 'patronym') // "Василий Иванович"
```

`apply`
---

Метод `apply()` вызывает функцию с указанным значением `this` и аргументами, предоставленными в виде массива

**Синтаксис**

`func.call(context, arg1, arg2, ...)`

При этом вызывается функция `func`, первый аргумент `call` становится её `this`, а остальные передаются «как есть».

Вызов `func.call(context, a, b...)` – то же, что обычный вызов `func(a, b...)`, но с явно указанным `this(=context)`.

Вы можете присваивать различные объекты `this` при вызове существующей функции. `this` ссылается на текущий объект, вызывающий объект. С помощью `apply()` вы можете написать метод один раз, а затем наследовать его в других объектах без необходимости переписывать метод для каждого нового объекта.

Метод `apply` очень похож на метод `call()`, за исключением поддерживаемого типа аргументов. Вы можете использовать массив аргументов вместо набора именованных параметров. Вместе с apply вы можете использовать литерал массива, например, `fun.apply(this, ['есть', 'бананы'])`, либо объект `Array`, например, `fun.apply(this, new Array('есть', 'бананы'))`.

Пример
```javascript
/* мин/макс числа в массиве */
var numbers = [5, 6, 2, 3, 7];

/* используем apply к Math.min/Math.max */
var max = Math.max.apply(null, numbers); /* Это эквивалентно Math.max(numbers[0], ...)
                                            или Math.max(5, 6, ...) */
var min = Math.min.apply(null, numbers);
```


`bind`
---

Метод `bind()` создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

**Синтаксис**

`func.bind(thisArg[, arg1[, arg2[, ...]]])`

Параметры

`thisArg`
    Значение, передаваемое в качестве this в целевую функцию при вызове привязанной функции. Значение игнорируется, если привязанная функция конструируется с помощью оператора new.

`arg1, arg2, ...`
    Аргументы целевой функции, передаваемые перед аргументами привязанной функции при вызове целевой функции.

*Методы `bind` и `call/apply` близки по синтаксису, но есть важнейшее отличие.
Методы `call/apply` вызывают функцию с заданным контекстом и аргументами.
А `bind` не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.*


**Пример: создание привязанной функции**

Простейшим способом использования `bind()` является создание функции, которая, вне зависимости от способа её вызова, вызывается с определённым значением `this`. Обычным заблуждением для новичков в JavaScript является извлечение метода из объекта с целью его дальнейшего вызова в качестве функции и ожидание того, что он будет использовать оригинальный объект в качестве своего значения `this` (например, такое может случиться при использовании метода как функции обратного вызова). Однако, без специальной обработки, оригинальный объект зачастую теряется. Создание привязанной функции из функции, использующей оригинальный объект, изящно решает эту проблему:

```javascript
this.x = 9;
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var getX = module.getX;
getX(); // 9, поскольку в этом случае this ссылается на глобальный объект

// создаём новую функцию с this, привязанным к module
var boundGetX = getX.bind(module);
boundGetX(); // 81
```
