## prototype, рассказ что это и как работает.
Основные понятия

* **прототипом** называется объект, на который указывает внутренняя ссылка [[Prototype]].
(на схеме ниже это Object Prototype и SuperType Prototype)

* **внутренний указатель на прототип**, которая в 5-ой редакции называется [[Prototype]], указывает на прототип текущего объекта, и по спецификации недоступна для разработки. Но в некоторых браузерах, нарушающих спецификацию, она открыта как свойство объекта `__proto__` ( но такое использование не кроссбраузерно и не корректно).
(на схеме ниже это свойство есть у объектов SuperType Prototype, SubType Prototype и instance)

* **свойство prototype** — это свойство функции (!важно отметить, что свойство именно функции), которое используют для передачи значения указателю [[prototype]] создаваемого объекта. Каждая функция создается со свойством prototype, значением которого является объект.
(на схеме ниже есть у конструкторов Object, SuperType и SubType)

#### Как работает прототип

Когда создается функция, по определенным правилам создается также ее свойство prototype.
По умолчанию во все прототипы автоматически добавляется свойство constructor, указывающее на функцию, к которой оно относится.
При определении пользовательского конструктора в прототип добавляется по умолчанию только свойство constructor, а все остальные методы наследуются от типа object.
Когда с помощью конструктора создается новый экземпляр типа, в экземпляре определяется внутренний указатель на прототип конструктора и не определяется свойство prototype.

Важно отметить наличие непосредственной связи между экземпляром и прототипом конструктора, но не между экземпляром и конструктором.

![Prototype](https://wiki.cochanges.com/download/attachments/23432210/prototype-diagram.png?version=1&modificationDate=1462544575853&api=v2 "Prototype")

В наследовании свойство prototype имеет смысл только для функции-Конструктора, благодаря ее способности передавать указатель в ссылку [[prototype]] создаваемого объекта.

Несколько прототипов одному объекту присвоить нельзя.

Любой javascript-объект имеет скрытую ссылку [[prototype]], которая связывает его с родительским по замыслу объектом, который в свою очередь со своим и т.д. Наверху всей этой цепочки находится прототип Object, имеющий все необходимые встроенные методы, такие как toString, valueOf, hasOwnProperty и т.д. Благодаря этому, все объекты потомки тоже имеют этот минимально необходимый набор методов. Сам прототип Object при этом не имеет скрытой ссылки [[prototype]].



#### Динамическая природа прототипа

Поскольку при доступе к значению, которого нет в экземпляре, выполняется его поиск в прототипе, изменения прототипа немедленно отражаются на экземплярах, в том числе на тех, которые существовали до изменения. Перезапись прототипа у конструктора приводит к тому, что новые экземпляры ссылаются на новый прототип, а уже существующие - на старый.



#### Некоторые методы при работе с наследованием:

* `isPrototypeOf()`
проверка наличия связи между объектом и прототипом. Вернет true, если скрытая ссылка [[Prototype]] экземпляра указывает на прототип, для которого вызван метод.
SubType.prototype.isPrototypeOf(instance) //вернет true

* `istanceof`
проверяет есть ли указанный конструктор в цепочке прототипов экземпляра
instance instanceof SuperType //вернет true

* `hasOwnProperty()`
позволяет выяснить, принадлежит ли свойство экземпляру, а не его прототипу. Вернет true, если свойство принадлежит экземпляру.
instance.hasOwnProperty('getSubValue') //вернет false
